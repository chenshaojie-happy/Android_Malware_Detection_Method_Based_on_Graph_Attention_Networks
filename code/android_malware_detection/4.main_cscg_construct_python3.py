# coding=utf-8
import os
from multiprocessing import Pool
from static import get_lsi_config, get_cscg_config, get_graph_config
from static import total_process_multi_core, total_process_single_core, ts_max, min_k_tmp_file
from lsi.lsi import lsi_train, lsi_test_cscg
from CSCG.calculate_min_k import calculate_min_k
from CSCG.java_graph import get_cscg_dataset
from GAT.create_graph_dataset import create_graph_files

program_root = os.getcwd()
# 添加apktool的环境变量
os.environ["PATH"] = program_root + '/tools/apktool/' + ":" + os.environ["PATH"]
# 添加jadx的环境变量
os.environ["PATH"] = program_root + '/tools/jadx/build/jadx/bin/' + ":" + os.environ["PATH"]


# 基于java文件的import关系进行图构建，相当于public class的调用关系，并保留一定的3rd库，使得过滤后节点数量小于100的，尽量补充到接近100
def class_set_call_graph(dataset):
    # dataset_name 数据集的名称,
    # java_path 原始java代码压缩包的存放路径,
    # java_graph_path 保存class-set call graph调用关系的路径,
    # _3rd_path 三方库文件的存放路径,
    # token_file_root 保存每个class-set的此法分析得到的tokens,
    # min_k 该数据集下的min_k值

    # 16.获取CSCG的配置信息
    java_path, java_graph_path, _3rd_path, token_file_root= get_cscg_config(dataset)
    train_file, test_file, TFIDF_dict_path, dict_corpus, TFIDF_model_path, TFIDF_corpus_path, LSI_model_path, LSI_corpus_path, LSI_corpus_path_test, token_root, apktool_root_path, no_below, no_above = get_lsi_config(dataset, type='cscg')

    # 17.计算min_k
    min_k = calculate_min_k(dataset, java_path, train_file, ts_max, min_k_tmp_file)

    # 18.计算CSCG调用图，并对节点进行分词
    get_cscg_dataset(dataset, java_path, java_graph_path, _3rd_path, token_file_root, min_k=min_k, total_process=total_process_single_core)

    # 提取class-set的LSI向量，每个APK保存成一个文件
    # pool = Pool(processes=2)
    # 19.生成训练集的节点特征向量
    lsi_test_cscg(dataset, train_file, TFIDF_dict_path, TFIDF_model_path, LSI_model_path, LSI_corpus_path, token_root, type='cscg')
    # pool.apply_async(lsi_test_cscg, (dataset, train_file, TFIDF_dict_path, TFIDF_model_path, LSI_model_path, LSI_corpus_path, token_root, 'cscg'))

    # 20.生成测试集的节点特征向量
    lsi_test_cscg(dataset, test_file, TFIDF_dict_path, TFIDF_model_path, LSI_model_path, LSI_corpus_path_test, token_root, type='cscg')
    # pool.apply_async(lsi_test_cscg, (dataset, test_file, TFIDF_dict_path, TFIDF_model_path, LSI_model_path, LSI_corpus_path_test, token_root, 'cscg'))
    # pool.close()
    # pool.join()

    # 防止多次调参时，读取碎文件太耗时间，因此先将CSCG保存成大文件
    pool = Pool(processes=2)

    # 21.读取PSCN的输入graph源文件
    train_file, test_file, LSI_corpus_path, LSI_corpus_path_test, graph_file_root, model_root, permission_feature_path, lsi_fearue_file, lsi_fearue_file_test = get_graph_config(dataset)

    # 22.生成训练集的graph文件
    # create_graph_files(train_file, graph_file_root, LSI_corpus_path, model_root, lsi_fearue_file, permission_feature_path=permission_feature_path, type='cscg', apktool_root_path=apktool_root_path, add_root=False)
    pool.apply_async(create_graph_files, (train_file, graph_file_root, LSI_corpus_path, model_root, lsi_fearue_file, permission_feature_path, 'cscg', apktool_root_path, False))

    # 23.生成测试集的graph文件
    # create_graph_files(test_file, graph_file_root, LSI_corpus_path_test, model_root, lsi_fearue_file_test, permission_feature_path=permission_feature_path, type='cscg',  apktool_root_path=apktool_root_path)
    pool.apply_async(create_graph_files, (test_file, graph_file_root, LSI_corpus_path_test, model_root, lsi_fearue_file_test, permission_feature_path, 'cscg', apktool_root_path, False))
    pool.close()
    pool.join()


if __name__ == '__main__':
    dataset = 'AMD_AndroZoo_demo'
    class_set_call_graph(dataset)

