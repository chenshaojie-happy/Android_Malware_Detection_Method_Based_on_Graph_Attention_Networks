# Android Malware Detection Method Based on Graph Attention Networks and Deep Fusion of Multimodal Features

## 1. 整体介绍(Overview)
&ensp;&ensp;&ensp;&ensp;本连接为《Android Malware Detection Method Based on Graph Attention Networks and Deep Fusion of Multimodal Features》的Python实现，
本代码由北京航空航天大学软件开发环境国家重点实验室海量信息处理与信息安全课题组提供。
论文引用信息：Chen, S., Lang, B., Liu, H., Chen, Y., Song, Y. (2024). Android malware detection method based on graph attention networks and deep fusion of multimodal features. Expert Systems with Applications. Expert Systems with Applications, 237, Article 121617. https://doi.org/10.1016/j.eswa.2023.121617.

&ensp;&ensp;&ensp;&ensp;This the Python implement of paper "Android Malware Detection Method Based on Graph Attention Networks and Deep Fusion of Multimodal Features",
which was provided by Massive Data Processing and Information Security Group of State Key Laboratory of Software Development Environment, Beihang University. 
Citation information: Chen, S., Lang, B., Liu, H., Chen, Y., Song, Y. (2024). Android malware detection method based on graph attention networks and deep fusion of multimodal features. Expert Systems with Applications. Expert Systems with Applications, 237, Article 121617. https://doi.org/10.1016/j.eswa.2023.121617.

## 2. 运行代码 (Run Code)

### 2.1 修改配置文件 (Modify the configuration file)

&ensp;&ensp;&ensp;&ensp;代码基于Ubuntu 18.04，cuda 10.1环境下运行。该代码由windows系统上传github，"tools/jadx/build/jadx/bin/jadx"和"tools/apktool/apktool"文件的运行权限会消失，需要在运行前执行 chmod a+x。

&ensp;&ensp;&ensp;&ensp;This code is based on Ubuntu 18.04 with CUDA 10.1. The code is uploaded to github by windows system, execute permission of "tools/jadx/build/jadx/bin/jadx" and "tools/apktool/apktool" would disappear, it needs to execute "chmod a+x" for the two files before running.

&ensp;&ensp;&ensp;&ensp;配置文件主要是static.py，内部root和root1需要提前配置。其中root用于存放运行阶段所有中间文件，考虑较大空间的机械硬盘;
root1用于临时存放jadx反编译得到的java文件，之后将java文件打包成zip文件，以减少IO占用。因此root1建议使用固态硬盘。

&ensp;&ensp;&ensp;&ensp;The configuration file is "static.py". Before running the code, the "root" and "root1" need to be configured in advance.
"root" is used to store all the intermediate files in the running phase, and the mechanical hard disk with large space is considered; 
"root1" is used to temporarily store the java files decompiled by JADX, after decompilation, the java code would be compressed into zip files to reduce the IO usage, 
therefore, "root1" recommends the use of solid state drivers.

&ensp;&ensp;&ensp;&ensp;此外，如新增数据集，则需要在static.py的tfidf_dict_para常量里增加数据集对应TFIDF的no_below和no_above。之后在1-5这5个python文件的main方法中修改数据集名。

&ensp;&ensp;&ensp;&ensp;In addition, if adding a new dataset, it is necessary to add "no_below" and "no_above" value of the dataset corresponding to TFIDF in "tfidf_dict_para" constant in static.py

&ensp;&ensp;&ensp;&ensp;原始apk文件存放在"../../dataset/"下的文件夹，对应样本训练集与测试集拆分以及样本标签存在的"data/"下对应的".filelist"文件里，其中a为malware，n为benign。

&ensp;&ensp;&ensp;&ensp;The original APK files are stored in the folder under "../../dataset/", the construction of training set and test set
and labels of samples are stored in the corresponding ".filelist" file in "data/" folder, in which "a" means malware, and "n" means benign sample. 

&ensp;&ensp;&ensp;&ensp;1-5，这5个python文件中的main方法包含数据集名，在运行前需要对应修改。

&ensp;&ensp;&ensp;&ensp;From 1 to 5, the 5 Python files contain the dataset name in the main method, which needs to be modified before running. 


### 2.1. 运行LibRadar (Run LibRadar)
&ensp;&ensp;&ensp;&ensp;由于LibRadar基于Python 2.7实现，较难迁移至Python 3下，选择单独运行 

&ensp;&ensp;&ensp;&ensp;Since LibRadar is implemented based on Python 2.7, it is difficult to run in python 3, we chose to run it separately.

    python2 1.main_literadar_python27.py

&ensp;&ensp;&ensp;&ensp;该部分会生成体积很大的log_libradar.txt, 并在"LiteRadar/Data/Decompiled/"下保留反编译的文件，需要及时清理

&ensp;&ensp;&ensp;&ensp;This part will generate a large log file named "log_libradar.txt", and keep the decompiled files in folder
 "LiteRadar/Data/Decompiled/", which needs to be cleaned up in time.

### 2.2. 运行预处理过程 (Preprocessing)
&ensp;&ensp;&ensp;&ensp;该部分包含apktool逆向、jadx反编译、完整APK的token提取、权限特征提取。

&ensp;&ensp;&ensp;&ensp;This part include apktool decompilation, jadx decompilation, token extraction of whole APK file, and permission feature extraction. 

&ensp;&ensp;&ensp;&ensp;之后为了确保我们的程序可以处理全部数据，我们对filelist的样本进行了筛选，去掉三方库、Java源代码等不完整的样本，并将筛选后的样本列表保存在"data/"下的".filter"文件内。

&ensp;&ensp;&ensp;&ensp;After that, to ensure that our code could process all the samples in the dataset, we filter the samples with incomplete third-party library detection results or Java source code,
and save the filtered sample list in the ".filter" file in folder "data/".

    python3 2.main_preprocess_python3.py

### 2.3. 训练LSI模型，并计算完整APK的LSI向量 (LSI model training and LSI vector of whole APK file calculation)
&ensp;&ensp;&ensp;&ensp;该部分实现我们之前的方法，作为本论文方法的基础。

&ensp;&ensp;&ensp;&ensp;This is the implements of our previous work, which is the basement of our method in this paper.

    Yucai Song, Yang Chen, Bo Lang, et al. Topic model based android malware detection[C]. International Conference on Security, Privacy and Anonymity in Computation, Communication and Storage, 2019: 384-396.

&ensp;&ensp;&ensp;&ensp;该部分首先基于训练集训练LSI模型，并计算训练集和测试集的LSI特征，并与权限特征拼接后训练XGBoost模型，并输出测试结果。

&ensp;&ensp;&ensp;&ensp;This part first trains the LSI model with training set, and calculates the LSI vectors of the training and testing datasets. 
And then it trains the XGBoost model after concatenating the LSI vector and permission features, and output the test result.

    python3 3.main_lsi_train_python3.py

### 2.4. CSCG构建 (Construction of CSCG)
&ensp;&ensp;&ensp;&ensp;该部分首先计算数据集的min_k；接下来构建全部的CSCG，包括节点合并、调用关系计算、以及节点的LSI特征计算；最后，为了保证多次调参减少IO的占用，
选择将整个数据集合并为大文件，防止每次训练读取大量碎文件。


&ensp;&ensp;&ensp;&ensp;This part first calculates the "min_k" of the dataset. And then it constructs the class-set call graph (CSCG), including node merging,
call relationship calculation and node LSI vector calculation. 
Finally, to reduce the IO usage, we choose to consolidate the entire dataset into large files to prevent reading large number of fragmented files for every training process. 


    python3 4.main_cscg_construct_python3.py

### 2.5. 模型训练与测试 (Model training and testing)
&ensp;&ensp;&ensp;&ensp;该部分对CSCG进行特征提取，并进行分类。对该模型的调参，则在"GAT/graph_net.py"中修改，通常主要修改 "self.args["lr"]" 和 "self.args["num_heads_per_layer"]" 两个参数，lr尝试0.001和0.002，num_heads_per_layer尝试2-8。

&ensp;&ensp;&ensp;&ensp;This part extracts features from CSCG and performs classification. The parameters of the model could be modified in "GAT/graph_net.py" file/
Usually, there are two parameters need to be adjusted, which are  "self.args["lr"]" and "self.args["num_heads_per_layer"]".
For "lr", we try 0.001 and 0.002; and for "num_heads_per_layer", we try 7 number which are from 2 to 8.

    python3 5.main_graph_test_python3.py

## 3. 引用 (Reference)

&ensp;&ensp;&ensp;&ensp;目前我们的论文处于审稿阶段，待接收后补充论文详细信息.

&ensp;&ensp;&ensp;&ensp;The paper is now under review, the details of the paper will be supplemented after acceptance. 

## 4. 其他 (Other notices)

&ensp;&ensp;&ensp;&ensp;当前工程基于AMD_AndroZoo数据集的子集构建的demo，该demo的中间文件已全部保留。

&ensp;&ensp;&ensp;&ensp;The current project is a demo on a subset of AMD_AndroZoo dataset. All intermediate files of the demo have been reserved.

&ensp;&ensp;&ensp;&ensp;真实数据集的文件太大，无法上传，仅保留了对应的3组模型文件

&ensp;&ensp;&ensp;&ensp;The files of the real datasets is too large, only the corresponding model files of the 3 datasets are reserved. 

&ensp;&ensp;&ensp;&ensp;如无需demo，则只需下载本文件夹，并确保外层的路径存在即可

&ensp;&ensp;&ensp;&ensp;If do not need the demo, it could just download this folder and make sure the outer folders exist.

## 注 (Note)：
&ensp;&ensp;&ensp;&ensp;当前版本为基于实验阶段原始代码进行整理得到，不排除存在一些bug，我们会后续修复。
&ensp;&ensp;&ensp;&ensp;Our current version of our code may still have some problems, and we will further improve it in the future.

